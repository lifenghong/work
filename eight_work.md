## 题目：
```假设你有一个长的花坛，其中一些地块种植，一些不是。然而，鲜花不能在相邻的地块种植 - 它们会争夺水分，两者都会死亡。

给定一个花坛（表示为包含0和1的数组，其中0表示空，1表示不为空）以及数字n，如果可以种植n朵新花而不违反无邻近花的规则，则返回花。

例1：
输入：花坛= [1,0,0,0,1]，n = 1
 输出：真
例2：
输入： flowerbed = [1,0,0,0,1]，n = 2
 输出： False
注意：
输入数组不会违反无邻近花的规则。
输入数组大小在[1,20000]的范围内。
n是一个不会超过输入数组大小的非负整数。
```
## 分析：
###### 这道题我第一次做的时候，用了普通的数组方法，遍历数组判断相邻元素为1或是0，判断元素是否为零，若为0，在判断他的左右两端是否为0；若为0，则count++；最后判断count的值是否大于n，若大于n，则可以，反之不可以。


## 代码实现：
```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& bed, int n) {
        for (int i = 0; i < bed.size(); i++) {
            if (!bed[i] && (i == 0 || !bed[i - 1]) && (i == bed.size() - 1 || !bed[i + 1])) {
                bed[i] = 1;
                n--;
            }
        }
        return n <= 0;
    }
};
```
