## 问题
```你需要用一个二叉树构造一个由括号和整数组成的字符串，并用前序遍历的方式。

空节点需要用空括号对“（）”表示。而且您需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
```
#### 列子
```
输入：二叉树：[1,2,3,4]
       1
     / \
    2 3
   /    
  4     

输出： “1（2（4））（3）”
 
说明： Originallay它需要是“1（2（4）（））（3（）（））”，
但是你需要省略所有不必要的空括号对。
它将是“1（2（4））（3）”。
```
## 问题分析
@ 用 递归的方法可以做，但刚开始我没弄懂，看了答案后才明白；对给定的二叉树进行前序遍历。在适当的位置使用大括号。但是。为了确保我们省略了不必要的大括号。为了做前序遍历，我们使用递归。我们打印当前节点并按顺序调用节点的左侧和右侧子节点的相同给定函数（如果它们存在的话）。

@ 情况1：当前节点存在左侧子节点和右侧子节点 我们需要将大括号放在()左边的孩子的前序遍历输出和右边的孩子的前序遍历输出中。

@ 情况2：当前节点没有左侧或右侧的子节点。考虑空白左右的空括号是多余的。因此，我们不需要为它们中的任何一个加上括号。
@ 情况3：当前节点仅存在左侧子节点。如下图所示，在考虑前序遍历的情况下，在这种情况下为正确的子项添加空括号是不必要的。这是因为在前序遍历中，正确的孩子总是会出现在左边的孩子之后。因此，省略右孩子的空括号也会导致字符串和二叉树之间的相同映射。
@ 情况4：只有当前节点存在正确的子节点。在这种情况下，我们需要考虑左侧的空括号。这是因为，在前序遍历期间，需要首先考虑左侧。因此，为了表明跟随当前节点的是正确的，我们需要为左侧放置一对空括号。
## 代码实现：
```cpp
**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public String tree2str(TreeNode t) {
        if(t==null)
            return "";
        if(t.left==null && t.right==null)
            return t.val+"";
        if(t.right==null)
            return t.val+"("+tree2str(t.left)+")";
        return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";   
    }
}
```
